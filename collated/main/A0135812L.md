# A0135812L
###### \java\seedu\address\commons\core\SortedObservableArrayList.java
``` java
/**
* Maintains a sorted database for the tasks
*/
public class SortedObservableArrayList<E extends Comparable<? super E>> implements ObservableList<E> {

    private ObservableList<E> backingList;
    public SortedObservableArrayList(){
        backingList = FXCollections.observableArrayList();
    }
    
    public SortedObservableArrayList(ObservableList<? extends E> backingList){
        this.backingList = FXCollections.observableArrayList();
        addAll(backingList);
    }
    @Override
    public int size() {
        return backingList.size();
    }

    @Override
    public boolean isEmpty() {
        return backingList.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        return backingList.contains(o);
    }

    @Override
    public Iterator<E> iterator() {
        return (Iterator<E>) backingList.iterator();
    }

    @Override
    public Object[] toArray() {
        return backingList.toArray();
    }

    @Override
    public <T> T[] toArray(T[] a) {
        return backingList.toArray(a);
    }

    @Override
    public boolean add(E e) {
        int index = Collections.binarySearch(backingList, e);
        if (index < 0) index = ~index;
        add(index, e);
        return true;
    }

    @Override
    public boolean remove(Object o) {
        return backingList.remove(o);
    }

    @Override
    public boolean containsAll(Collection<?> c) {
        return backingList.containsAll(c);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        
        for(E e: c){
            add(e);
        }
        return true;
    }

    @Override
    public boolean addAll(int index, Collection<? extends E> c) {
        return false;
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return backingList.removeAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return backingList.retainAll(c);
    }

    @Override
    public void clear() {
        backingList.clear();
    }

    @Override
    public E get(int index) {
        return backingList.get(index);
    }

    @Override
    public E set(int index, E element){
        remove(index);
        add(element);
        return get(indexOf(element));
    }

    @Override
    public void add(int index, E element) {
        backingList.add(index, element);
    }

    @Override
    public E remove(int index) {
        return backingList.remove(index);
    }

    @Override
    public int indexOf(Object o) {
        return backingList.indexOf(o);
    }

    @Override
    public int lastIndexOf(Object o) {
        return backingList.lastIndexOf(o);
    }

    @Override
    public ListIterator<E> listIterator() {
        return backingList.listIterator();
    }

    @Override
    public ListIterator<E> listIterator(int index) {
        return backingList.listIterator(index);
    }

    @Override
    public List<E> subList(int fromIndex, int toIndex) {
        return backingList.subList(fromIndex, toIndex);
    }

    @Override
    public void addListener(InvalidationListener listener) {
        backingList.addListener(listener);
    }

    @Override
    public void removeListener(InvalidationListener listener) {
        backingList.removeListener(listener);
    }

    @Override
    public void addListener(ListChangeListener<? super E> listener) {
        backingList.addListener(listener);
    }

    @Override
    public void removeListener(ListChangeListener<? super E> listener) {
        backingList.removeListener(listener);
    }

    @Override
    public boolean addAll(E... elements) {
        for(E e: elements){
            add(e);
        }
        return true;
    }

    @Override
    public boolean setAll(E... elements) {
        clear();
        return addAll(elements);
    }

    @Override
    public boolean setAll(Collection<? extends E> col) {
        clear();
        return addAll(col);
    }

    @Override
    public boolean removeAll(E... elements) {
        return backingList.removeAll(elements);
    }

    @Override
    public boolean retainAll(E... elements) {
        return backingList.retainAll(elements);
    }

    @Override
    public void remove(int from, int to) {
        backingList.remove(from, to);
    }
    
    @Override
    public boolean equals(Object o){
        if(o instanceof SortedObservableArrayList){
            SortedObservableArrayList other = (SortedObservableArrayList) o;
            return containsAll(other);
        }else{
            return false;
        }
    }

}
```
###### \java\seedu\address\commons\events\ui\TaskCardMarkChangedEvent.java
``` java
public class TaskCardMarkChangedEvent extends BaseEvent{

    private final int displayedIndex;
    
    public TaskCardMarkChangedEvent(int displayedIndex){
        this.displayedIndex = displayedIndex;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public int getDisplayedIndex() {
        return displayedIndex;
    }
      

}
```
###### \java\seedu\address\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult prompt() {
        ConfirmCommand.AWAITINGCONFIRMATION = this;
        return prompt(COMMAND_WORD);
    }
}
```
###### \java\seedu\address\logic\commands\ConfirmCommand.java
``` java
/**
 * Confirms the RequiresConfirm implemented Command
 * @author A0135812L
 *
 */
public class ConfirmCommand extends Command {
    public static Command AWAITINGCONFIRMATION = null;
    public static final  String MESSAGE = "Yes?";
    public static final String COMMAND_WORD = "yes";
    
    public ConfirmCommand(){
        
    }
    
    @Override
    public CommandResult execute() {
        if(AWAITINGCONFIRMATION!=null){
            return AWAITINGCONFIRMATION.execute();
        }else{
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE);
        }
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
/**
 * Adds a task to the SmartyDo.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits a task to the SmartyDo. "
            + "Parameters: INDEX [PREFIX INPUT]..."
            + "Example: " + COMMAND_WORD
            + " CS2103 t;10-12-2016 10:00AM 11:00AM d;description a;Nus Computing t/sadLife";

    public static final String MESSAGE_SUCCESS = "Task edited: %1$s";


    public final int targetIndex;
    private ReadOnlyTask taskToEdit;
    private HashMap<String, List<String>> field_and_newValue_pair;

    /**
     * Convenience constructor using raw values.
     *
     */
    public EditCommand(int targetIndex, HashMap<String, List<String>> field_and_newValue_pair){
    	this.targetIndex = targetIndex;
    	this.field_and_newValue_pair = field_and_newValue_pair;
    }

    @Override
    public CommandResult execute() {

        assert model != null;
        assert undoRedoManager != null;

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToEdit = lastShownList.get(targetIndex - 1);
        Class<? extends ReadOnlyTask> taskClazz = Task.class;
        HashMap<Field, Object> changesToBeMade = new HashMap<>();
        ReadOnlyTask editedTask = null;
        try {
            for(Entry<String, List<String>> entry : field_and_newValue_pair.entrySet()){
                
                String fieldString = entry.getKey();
                List<String> valueString = entry.getValue();
                Class<?>[] argTypes = new Class[valueString.size()];
                for(int i=0; i<valueString.size(); i++){
                    argTypes[i] = valueString.get(0).getClass();
                }
                
                Field field = taskClazz.getDeclaredField(fieldString);
                Object new_value = getObject(valueString, field);
                assert new_value !=null;
                changesToBeMade.put(field, new_value);
            }
            editedTask = model.editTask(taskToEdit, changesToBeMade);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (NoSuchFieldException e){
            e.printStackTrace();
            assert false : "Checking of inputs'validity should be done in parser.";
        } catch (Exception e) {
            e.printStackTrace();
            assert false : e.getMessage();
        }
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, editedTask));
    }

 // Modified from http://stackoverflow.com/a/13872171/7068957
    private Object getObject(List<String> valueString, Field field)
            throws InstantiationException, IllegalAccessException, InvocationTargetException {
        Class type;
        if(field.getType()==Optional.class){
            assert field.getName() == "time";
            type = Time.class;
        }else{
            type= field.getType();
        }
        for (Constructor<?> ctor : type.getConstructors()) {
            Class<?>[] paramTypes = ctor.getParameterTypes();
            // If the arity matches, let's use it.
            if (valueString.size() == paramTypes.length) {
                return newInstance(valueString, ctor);
            }
        }
        return null;
    }

    private Object newInstance(List<String> valueString, Constructor<?> ctor)
            throws InstantiationException, IllegalAccessException, InvocationTargetException {
        try{
            return ctor.newInstance(valueString);
        }catch(IllegalArgumentException e){
            if(valueString.size()==1){
                return ctor.newInstance(valueString.get(0));
            }else if(valueString.size()==2){
                return ctor.newInstance(valueString.get(0), valueString.get(1));
            }else{
                return ctor.newInstance(valueString.get(0), valueString.get(1), valueString.get(2));
            }
        }
        
    }

}

```
###### \java\seedu\address\logic\commands\RequiresConfirm.java
``` java
public interface RequiresConfirm{
    /**
     * Remember to confirm these commands if they are to be used in testing.
     */
    
    public static String PROMPT_MESSAGE = "Are you sure you want to execute ' %1$s ' ? Type ' yes ' to confirm.";    
    
    default CommandResult prompt(String commandWord){
        return new CommandResult(String.format(PROMPT_MESSAGE, commandWord));
    }

    
    /** This is for the injection of the COMMAND_WORD 
     * and updating the latest command that is waiting for confirmation.
     * Sample Code is given below for easy implementation.
     * @return CommandResult by calling prompt(String)
     */
    /* Sample Code
    public CommandResult prompt() {
        ConfirmCommand.AWAITINGCONFIRMATION = this;
        return prompt(COMMAND_WORD);
    }
    */
    public CommandResult prompt();
    
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private static final Pattern TASK_EDIT_ARGS_FORMAT = Pattern.compile("(?<targetIndex>\\d+)(?<arguments>.+)");
    private Command prepareEdit(String allArgs){
        final Matcher matcher = TASK_EDIT_ARGS_FORMAT.matcher(allArgs.trim());
        if(!matcher.matches()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        int index = Integer.parseInt(matcher.group("targetIndex"));
        String args = matcher.group("arguments");

        HashMap<Prefix,String> prefix_to_fieldName= new HashMap<>();
        prefix_to_fieldName.put(datePrefix, "time");
        prefix_to_fieldName.put(periodPrefix, "period");
        prefix_to_fieldName.put(descriptionPrefix, "description");
        prefix_to_fieldName.put(locationPrefix, "location");
        prefix_to_fieldName.put(tagsPrefix, "tags");
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, datePrefix, periodPrefix, descriptionPrefix,
                locationPrefix, tagsPrefix);
        
        argsTokenizer.tokenize(args);
        HashMap<String, List<String>> field_and_newValue_pair = new HashMap<>();
        
        try {
            Optional<String> taskName = getTaskNameFromArgs(argsTokenizer);
            if(taskName.isPresent()){
                List<String> input = new ArrayList<String>();
                input.add(taskName.get());
                field_and_newValue_pair.put("name",input);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
        
        // Validate arg string format
        for(Prefix prefix : prefix_to_fieldName.keySet()){
            Optional<List<String>> input = argsTokenizer.getAllValues(prefix);
            if(input.isPresent()){
                field_and_newValue_pair.put(prefix_to_fieldName.get(prefix), input.get());
            }
        }
        return new EditCommand(index, field_and_newValue_pair);
    }
```
###### \java\seedu\address\model\task\ReadOnlyTask.java
``` java
    @Override
    public default int compareTo(ReadOnlyTask o) {
        if(!this.getTime().isPresent()){
            return -1;
        }else if(!o.getTime().isPresent()){
            return 1;
        }else{
            return this.getTime().get().compareTo(o.getTime().get());
        }
    }
```
###### \java\seedu\address\model\task\Time.java
``` java
    /**
     * This determines the natural ordering of the task.
     *
     * @return type of task
     */
    @Override
    public int compareTo(Time other) {

        LocalDateTime thisStartDateTime = this.startDate;
        LocalDateTime otherStartDateTime = other.startDate;
        LocalDate thisStartDate = thisStartDateTime.toLocalDate();
        LocalDate otherStartDate = otherStartDateTime.toLocalDate();

        // Compare Date first. Unable to compare DateTime directly as some might be untimed
        int cmp = thisStartDate.compareTo(otherStartDate);
        if(cmp!=0){
            return cmp;
        }
        // If it is on the same date but "this" is untimed it will go before the other
        if(this.isUntimed){
            return -1;
        }else if(other.isUntimed){
            // If it is on the same date but other is untimed "this" will go after other
            return 1;
        }

        LocalTime thisStartTime = thisStartDateTime.toLocalTime();
        LocalTime otherStartTime = otherStartDateTime.toLocalTime();
        cmp = thisStartTime.compareTo(otherStartTime);
        if(cmp!=0){
            return cmp;
        }

        if(!this.getEndDate().isPresent()){
            return -1;
        }else if(!other.getEndDate().isPresent()){
            return 1;
        }

        LocalDateTime thisEndDateTime = this.getEndDate().get();
        LocalDateTime otherEndDateTime = other.getEndDate().get();

        cmp = thisEndDateTime.compareTo(otherEndDateTime);
        return cmp;
    }
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Edits the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws SecurityException 
     * @throws NoSuchFieldException 
     * @throws IllegalAccessException 
     * @throws IllegalArgumentException 
     */
    public Task edit(ReadOnlyTask toEdit, HashMap<Field, Object> changes) throws TaskNotFoundException, IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
        assert toEdit != null;
        final boolean taskFound = internalList.contains(toEdit);
        if (!taskFound) {
            throw new TaskNotFoundException();
        }else{
            final int taskFoundAt = internalList.indexOf(toEdit);
            Task original = internalList.get(taskFoundAt);
            Task edited = original.setFields(changes);
            internalList.set(taskFoundAt, edited);
            return edited;
        }
    }
```
###### \java\seedu\address\ui\MainWindow.java
``` java
	public void markTaskCard(int i){
	    logic.execute(String.format("%1$s %2$d", DoneCommand.COMMAND_WORD, i));
	}
}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
    private void setEventHandlerForMarkChangedEvent(){
        completeStatus.selectedProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskCardMarkChangedEvent(displayedIndex));
            }
        });
    }
}
```
###### \java\seedu\address\ui\TitleCard.java
``` java
    private void setEventHandlerForMarkChangedEvent(){
        completeStatus.selectedProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskCardMarkChangedEvent(displayedIndex));
            }
        });
    }
}
```
###### \java\seedu\address\ui\UiManager.java
``` java
    @Subscribe
    private void handleTaskCardMarkChangedEvent(TaskCardMarkChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.markTaskCard(event.getDisplayedIndex());
    }

}
```
